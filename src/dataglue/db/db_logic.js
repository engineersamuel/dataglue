// Generated by CoffeeScript 1.6.2
(function() {
  var CachedDataSet, EventEmitter, async, dataSetCache, logger, mysql, prettyjson, settings, squel, utils, _;

  settings = require('../utilitis/settings');

  utils = require('../utilitis/utils');

  dataSetCache = require('../db/dataset_cache');

  squel = require('squel');

  _ = require('lodash');

  async = require('async');

  mysql = require('mysql');

  logger = require('tracer').colorConsole(utils.logger_config);

  prettyjson = require('prettyjson');

  EventEmitter = require("events").EventEmitter;

  CachedDataSet = new EventEmitter();

  CachedDataSet.buildSql = function(dbReference, callback) {
    var d3Lookup, output, self, sql, type;

    self = this;
    type = settings.db_refs[dbReference['connection']]['type'];
    d3Lookup = {
      key: void 0,
      x: void 0,
      y: void 0,
      y2: void 0,
      z: void 0
    };
    output = {
      sql: void 0,
      d3Lookup: void 0
    };
    if (type === 'mysql') {
      sql = squel.select();
      sql.from("" + dbReference.schema + "." + dbReference.table);
      _.each(dbReference.fields, function(field) {
        var field_alias, field_name;

        if (field['excluded'] == null) {
          field_name = field.COLUMN_NAME;
          field_alias = void 0;
          if (_.has(field, 'aggregation')) {
            if (field.aggregation === 'count') {
              field_alias = 'y';
              sql.field("COUNT(" + field_name + ")", field_alias);
              d3Lookup.y = field_name;
              d3Lookup.key = "" + field_name + " count";
            }
          } else {
            sql.field(field_name);
          }
          if (_.has(field, 'beginDate')) {
            sql.where("" + field_name + " >= TIMESTAMP('" + field.beginDate + "')");
          }
          if (_.has(field, 'endDate')) {
            sql.where("" + field_name + " < TIMESTAMP('" + field.endDate + "')");
          }
          if (_.has(field, 'groupBy')) {
            if (field.groupBy === 'day') {
              field_alias = 'x';
              sql.field("DATE_FORMAT(" + field_name + ", '%Y-%m-%d')", field_alias);
              sql.group(field_alias);
              return d3Lookup.x = field_alias;
            }
          }
        }
      });
      output.sql = sql.toString();
      output.d3Lookup = d3Lookup;
      callback(null, output);
    }
    return self;
  };

  CachedDataSet.mysqlQuery = function(dbReference, queryHash, callback) {
    var conn, mysql_ref, self;

    self = this;
    mysql_ref = settings.mysql_refs[dbReference.connection];
    conn = mysql.createConnection({
      host: mysql_ref['host'],
      user: mysql_ref['user'],
      password: mysql_ref['pass']
    });
    logger.debug("Querying mysql reference: " + dbReference.connection + " with sql: " + queryHash);
    conn.query(queryHash.sql, function(err, results) {
      var q;

      if (err) {
        logger.debug("Error Querying mysql reference: " + dbReference.connection + " with sql: " + queryHash + ", err: " + (prettyjson.render(err)));
        callback(err);
      } else {
        logger.debug("Found " + results.length + " results");
        q = dataSetCache.statementCachePut(dbReference, queryHash, results);
        q.on('failure', function(cacheError) {
          return logger.error("Failed to cache sql due to: " + (prettyjson.render(cacheError)));
        });
        q.on('cachePut', function() {
          return callback(null, results);
        });
      }
      return conn.end();
    });
    return self;
  };

  CachedDataSet.queryDynamic = function(dbReference, callback) {
    var key, output, self;

    self = this;
    output = {};
    key = dbReference['key'];
    output = {};
    output[key] = {
      results: void 0,
      queryHash: void 0
    };
    CachedDataSet.buildSql(dbReference, function(err, queryHash) {
      if (err) {
        logger.error("Error building SQL: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        return dataSetCache.statementCacheGet(dbReference, queryHash, function(err, results) {
          if (err) {
            return callback(err);
          } else {
            output[key].queryHash = queryHash;
            if (results != null) {
              output[key].results = results;
              return callback(null, output);
            } else {
              return CachedDataSet.mysqlQuery(dbReference, queryHash, function(err, results) {
                output[key].queryHash = queryHash;
                output[key].results = results;
                return callback(err, output);
              });
            }
          }
        });
      }
    });
    return self;
  };

  CachedDataSet.loadDataSet = function(doc, callback) {
    var self;

    self = this;
    doc = _.isString(doc) ? JSON.parse(doc) : doc;
    async.map(_.values(doc.dbReferences), self.queryDynamic, function(err, arrayOfHashes) {
      if (err) {
        logger.error("Error querying dbReferences: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        return _.each(arrayOfHashes, function(resultsHash) {
          _.each(resultsHash, function(theHash, dbRefKey) {
            var dbReference, stream;

            dbReference = doc[dbRefKey];
            stream = {
              key: theHash.queryHash.d3Lookup.key,
              values: []
            };
            _.each(theHash.results, function(item) {
              return stream.values.push({
                x: item.x,
                y: item.y
              });
            });
            return resultsHash[dbRefKey].d3Data = stream;
          });
          return callback(null, arrayOfHashes);
        });
      }
    });
    return self;
  };

  CachedDataSet.queryDataSet = function(arg, callback) {
    return this.loadDataSet(arg, function(err, results) {
      return callback(err, results);
    });
  };

  module.exports = CachedDataSet;

}).call(this);

/*
//@ sourceMappingURL=db_logic.map
*/
