// Generated by CoffeeScript 1.6.2
(function() {
  var DataSetCache, EventEmitter, generate_mongo_url, logger, md5, mongo_url, mongodb, prettyjson, settings, snappy, utils, zlib;

  settings = require('../utilitis/settings');

  utils = require('../utilitis/utils');

  logger = require('tracer').colorConsole(utils.logger_config);

  mongodb = require('mongodb');

  snappy = require('snappy');

  zlib = require('zlib');

  md5 = require('MD5');

  prettyjson = require('prettyjson');

  EventEmitter = require("events").EventEmitter;

  generate_mongo_url = function(obj) {
    obj.host = obj.host || '127.0.0.1';
    obj.port = obj.port || 27017;
    obj.db = obj.db || 'test';
    if (obj.user && obj.pass) {
      return "mongodb://" + obj.user + ":" + obj.pass + "@" + obj.host + ":" + obj.port + "/" + obj.db + "?auto_reconnect=true";
    } else {
      return "mongodb://" + obj.host + ":" + obj.port + "/" + obj.db;
    }
  };

  mongo_url = generate_mongo_url(settings.master_ref);

  DataSetCache = new EventEmitter();

  DataSetCache.ref_get = function(_id, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      } else {
        return conn.collection(settings.master_ref.collection, function(err, coll) {
          if (err) {
            callback(err);
            return conn.close();
          } else {
            logger.debug(_id);
            return coll.findOne({
              _id: mongodb.ObjectID(_id)
            }, function(err, doc) {
              if (err) {
                callback(err);
                return conn.close();
              } else {
                callback(null, doc);
                return conn.close();
              }
            });
          }
        });
      }
    });
    return self;
  };

  DataSetCache.statementCacheGet = function(dbReference, queryHash, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      }
      return conn.collection(settings.master_ref.cache, function(err, coll) {
        var hash;

        if (err) {
          callback(err);
          return conn.close();
        } else {
          hash = md5("" + dbReference.key + queryHash.sql);
          return coll.findOne({
            md5: hash
          }, function(err, doc) {
            if (err) {
              callback(err);
              conn.close();
            } else if (doc == null) {
              logger.debug("Cache miss for hash: " + hash + ", sql: " + queryHash.sql);
              callback(null, null);
            } else {
              logger.debug("Cache hit for hash: " + hash + ", sql: " + queryHash.sql);
              zlib.unzip(new Buffer(doc['data'], 'base64'), function(err, results) {
                if (err != null) {
                  logger.error("Error decompressing data: " + err);
                  return callback(err);
                } else {
                  return callback(null, JSON.parse(results));
                }
              });
            }
            return conn.close();
          });
        }
      });
    });
    return self;
  };

  DataSetCache.statementCachePut = function(dbReference, queryHash, results) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        self.emit('failure', err);
      }
      return conn.collection(settings.master_ref.cache, function(err, coll) {
        var hash;

        if (err) {
          return self.emit('failure', err);
        } else {
          hash = md5("" + dbReference.key + queryHash.sql);
          return zlib.deflate(JSON.stringify(results), function(err, buffer) {
            if (err) {
              logger.error("Problem compressing data: " + err);
              self.emit('failure', err);
              return conn.close();
            } else {
              return coll.update({
                md5: hash
              }, {
                $set: {
                  sql: queryHash.sql,
                  data: buffer.toString('base64'),
                  last_touched: new Date()
                }
              }, {
                upsert: true
              }, function(err, outcome) {
                if (err) {
                  self.emit('failure', err);
                } else {
                  self.emit('cachePut');
                }
                return conn.close();
              });
            }
          });
        }
      });
    });
    return self;
  };

  DataSetCache.ref_upsert = function(doc) {
    var self;

    self = this;
    return this;
  };

  module.exports = DataSetCache;

}).call(this);

/*
//@ sourceMappingURL=dataset_cache.map
*/
