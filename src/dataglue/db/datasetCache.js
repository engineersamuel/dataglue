// Generated by CoffeeScript 1.6.2
(function() {
  var DataSetCache, generate_mongo_url, logger, md5, mongo_url, mongodb, prettyjson, settings, utils, zlib, _;

  settings = require('../utilitis/settings');

  utils = require('../utilitis/utils');

  logger = require('tracer').colorConsole(utils.logger_config);

  mongodb = require('mongodb');

  zlib = require('zlib');

  md5 = require('MD5');

  _ = require('lodash');

  prettyjson = require('prettyjson');

  generate_mongo_url = function(obj) {
    obj.host = obj.host || '127.0.0.1';
    obj.port = obj.port || 27017;
    obj.db = obj.db || 'test';
    if (obj.user && obj.pass) {
      return "mongodb://" + obj.user + ":" + obj.pass + "@" + obj.host + ":" + obj.port + "/" + obj.db + "?auto_reconnect=true";
    } else {
      return "mongodb://" + obj.host + ":" + obj.port + "/" + obj.db;
    }
  };

  mongo_url = generate_mongo_url(settings.master_ref);

  DataSetCache = {};

  DataSetCache.refDelete = function(_id, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      } else {
        return conn.collection(settings.master_ref.collection, function(err, coll) {
          if (err) {
            callback(err);
            return conn.close();
          } else {
            return coll.remove({
              _id: mongodb.ObjectID(_id)
            }, {
              w: 1
            }, function(err, outcome) {
              callback(err, outcome);
              return conn.close();
            });
          }
        });
      }
    });
    return self;
  };

  DataSetCache.refGet = function(_id, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      } else {
        return conn.collection(settings.master_ref.collection, function(err, coll) {
          if (err) {
            callback(err);
            return conn.close();
          } else {
            logger.debug(_id);
            return coll.findOne({
              _id: mongodb.ObjectID(_id)
            }, function(err, doc) {
              if (err) {
                callback(err);
                return conn.close();
              } else {
                callback(null, doc);
                return conn.close();
              }
            });
          }
        });
      }
    });
    return self;
  };

  DataSetCache.refUpsert = function(doc, callback) {
    _.each(doc.dbReferences, function(value, key) {
      return _.each(value.fields, function(field) {
        if (_.has(field, '$$hashKey')) {
          return delete field['$$hashKey'];
        }
      });
    });
    return mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      } else {
        return conn.collection(settings.master_ref.collection, function(err, coll) {
          var _id;

          if (err) {
            callback(err);
            conn.close();
          } else {

          }
          if (_.has(doc, '_id')) {
            _id = mongodb.ObjectID(doc['_id']);
            doc['_id'] = _id;
            return coll.update({
              _id: _id
            }, doc, {
              upsert: true
            }, function(err, outcome) {
              if (err) {
                callback(err);
              } else {
                callback(null, _id.toString());
              }
              return conn.close();
            });
          } else {
            return coll.insert(doc, {
              safe: true
            }, function(err, insertedId) {
              if (err) {
                logger.warn(err.message);
              }
              if (err && err.message.indexOf('E11000') !== -1) {
                logger.error("This _id was already inserted in the database");
              }
              if (err) {
                callback(err);
              } else {
                logger.debug(prettyjson.render("insertedId: " + insertedId));
                callback(null, doc['_id'].toString());
              }
              return conn.close();
            });
          }
        });
      }
    });
  };

  DataSetCache.statementCacheGet = function(dbReference, queryHash, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        return callback(err);
      }
      return conn.collection(settings.master_ref.cache, function(err, coll) {
        var hash;

        if (err) {
          callback(err);
          return conn.close();
        } else {
          hash = md5("" + dbReference.key + queryHash.sql);
          return coll.findOne({
            md5: hash
          }, function(err, doc) {
            if (err) {
              callback(err);
              conn.close();
            } else if (doc == null) {
              logger.debug("Cache miss for hash: " + hash + ", sql: " + queryHash.sql);
              callback(null, null);
            } else {
              logger.debug("Cache hit for hash: " + hash + ", sql: " + queryHash.sql);
              zlib.unzip(new Buffer(doc['data'], 'base64'), function(err, results) {
                if (err != null) {
                  logger.error("Error decompressing data: " + err);
                  return callback(err);
                } else {
                  return callback(null, JSON.parse(results));
                }
              });
            }
            return conn.close();
          });
        }
      });
    });
    return self;
  };

  DataSetCache.statementCachePut = function(dbReference, queryHash, results, callback) {
    var self;

    self = this;
    logger.debug("Connecting to mongo on: " + mongo_url);
    mongodb.connect(mongo_url, function(err, conn) {
      if (err) {
        logger.error(prettyjson.render(err));
        return callback(err);
      } else {
        return conn.collection(settings.master_ref.cache, function(err, coll) {
          var hash;

          if (err) {
            return callback(err);
          } else {
            hash = md5("" + dbReference.key + queryHash.sql);
            return zlib.deflate(JSON.stringify(results), function(err, buffer) {
              if (err) {
                logger.error("Problem compressing data: " + err);
                callback(err);
                return conn.close();
              } else {
                return coll.update({
                  md5: hash
                }, {
                  $set: {
                    sql: queryHash.sql,
                    data: buffer.toString('base64'),
                    last_touched: new Date()
                  }
                }, {
                  upsert: true
                }, function(err, outcome) {
                  if (err) {
                    callback(err);
                  } else {
                    callback(null, outcome);
                  }
                  return conn.close();
                });
              }
            });
          }
        });
      }
    });
    return self;
  };

  module.exports = DataSetCache;

}).call(this);

/*
//@ sourceMappingURL=datasetCache.map
*/
