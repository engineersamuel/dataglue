// Generated by CoffeeScript 1.6.2
(function() {
  var CachedDataSet, async, dataSetCache, logger, mysql, prettyjson, settings, squel, utils, _;

  settings = require('../utilitis/settings');

  utils = require('../utilitis/utils');

  dataSetCache = require('../db/dataset_cache');

  squel = require('squel');

  _ = require('lodash');

  async = require('async');

  mysql = require('mysql');

  logger = require('tracer').colorConsole(utils.logger_config);

  prettyjson = require('prettyjson');

  CachedDataSet = {};

  CachedDataSet.buildSql = function(dbReference, callback) {
    var d3Lookup, output, self, sql, type;

    self = this;
    type = settings.db_refs[dbReference['connection']]['type'];
    d3Lookup = {
      key: void 0,
      x: void 0,
      xType: void 0,
      y: void 0,
      yType: void 0,
      y2: void 0,
      y2Type: void 0,
      z: void 0,
      zType: void 0,
      r: void 0,
      rType: void 0
    };
    output = {
      sql: void 0,
      d3Lookup: void 0
    };
    if (type === 'mysql') {
      sql = squel.select();
      sql.from("" + dbReference.schema + "." + dbReference.table);
      _.each(dbReference.fields, function(field) {
        var field_alias, field_name;

        if (field['excluded'] == null) {
          field_name = field.COLUMN_NAME;
          field_alias = void 0;
          if (_.has(field, 'aggregation')) {
            field_alias = 'y';
            if (field.aggregation === 'count') {
              sql.field("COUNT(" + field_name + ")", field_alias);
              d3Lookup.key = "" + field_name + " count";
            } else if (field.aggregation === 'distinctCount') {
              sql.field("COUNT(DISTINCT " + field_name + ")", field_alias);
              d3Lookup.key = "" + field_name + " distinct count";
            } else if (field.aggregation === 'sum') {
              sql.field("SUM(" + field_name + ")", field_alias);
              d3Lookup.key = "" + field_name + " sum";
            } else if (field.aggregation === 'avg') {
              sql.field("AVG(" + field_name + ")", field_alias);
              d3Lookup.key = "" + field_name + " avg";
            }
            d3Lookup.y = field_name;
            d3Lookup.yType = field.DATA_TYPE;
          } else {
            sql.field(field_name);
          }
          if (_.has(field, 'beginDate')) {
            sql.where("" + field_name + " >= TIMESTAMP('" + field.beginDate + "')");
          }
          if (_.has(field, 'endDate')) {
            sql.where("" + field_name + " < TIMESTAMP('" + field.endDate + "')");
          }
          if (_.has(field, 'groupBy')) {
            field_alias = 'x';
            d3Lookup.x = field_alias;
            d3Lookup.xType = field.DATA_TYPE;
            d3Lookup.xGroupBy = field.groupBy;
            if (field.groupBy === 'hour') {
              sql.field("DATE_FORMAT(" + field_name + ", '%Y-%m-%d %H')", field_alias);
            } else if (field.groupBy === 'day') {
              sql.field("DATE_FORMAT(" + field_name + ", '%Y-%m-%d')", field_alias);
            } else if (field.groupBy === 'month') {
              sql.field("DATE_FORMAT(" + field_name + ", '%Y-%m')", field_alias);
            } else if (field.groupBy === 'year') {
              sql.field("DATE_FORMAT(" + field_name + ", '%Y-%m')", field_alias);
            }
            return sql.group(field_alias);
          }
        }
      });
      output.sql = sql.toString();
      output.d3Lookup = d3Lookup;
      callback(null, output);
    }
    return self;
  };

  CachedDataSet.mysqlQuery = function(dbReference, queryHash, callback) {
    var conn, mysql_ref, self;

    self = this;
    mysql_ref = settings.mysql_refs[dbReference.connection || dbReference.name];
    conn = mysql.createConnection({
      host: mysql_ref['host'],
      user: mysql_ref['user'],
      password: mysql_ref['pass']
    });
    logger.debug("Querying mysql reference: " + dbReference.connection + " with sql: " + queryHash);
    conn.query(queryHash.sql, function(err, results) {
      if (err) {
        logger.debug("Error Querying mysql reference: " + dbReference.connection + " with sql: " + queryHash + ", err: " + (prettyjson.render(err)));
        callback(err);
      } else {
        logger.debug("Found " + results.length + " results.");
        if (queryHash.cache != null) {
          dataSetCache.statementCachePut(dbReference, queryHash, results, function(err, outcome) {
            if (err) {
              return logger.error("Failed to cache sql due to: " + (prettyjson.render(err)));
            } else {
              return callback(null, results);
            }
          });
        } else {
          callback(null, results);
        }
      }
      return conn.end();
    });
    return self;
  };

  CachedDataSet.query = function(dbReference, queryHash, callback) {
    var self;

    self = this;
    if (dbReference.type === 'mysql') {
      logger.debug("Querying mysql reference: " + dbReference.name + " with sql: " + queryHash.sql);
      CachedDataSet.mysqlQuery(dbReference, queryHash, function(err, results) {
        if (err) {
          return callback(err);
        } else {
          return callback(null, results);
        }
      });
    }
    return self;
  };

  CachedDataSet.getFields = function(dbRefName, schemaName, tableName, callback) {
    var dbReference, sql;

    dbReference = settings.db_refs[dbRefName];
    sql = "SELECT COLUMN_NAME, DATA_TYPE, COLUMN_KEY, COLUMN_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + schemaName + "' AND TABLE_NAME = '" + tableName + "'";
    CachedDataSet.query(dbReference, {
      sql: sql,
      cache: false
    }, function(err, fields) {
      return callback(err, fields);
    });
    return this;
  };

  CachedDataSet.getTables = function(dbRefName, schemaName, callback) {
    var dbReference, sql;

    dbReference = settings.db_refs[dbRefName];
    sql = "SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + schemaName + "'";
    CachedDataSet.query(dbReference, {
      sql: sql,
      cache: false
    }, function(err, results) {
      return callback(err, _.map(results));
    });
    return this;
  };

  CachedDataSet.getSchemas = function(dbRefName, callback) {
    var dbReference, sql;

    logger.debug("Call to getSchemas");
    dbReference = settings.db_refs[dbRefName];
    sql = 'SELECT SCHEMA_NAME AS `schema` FROM INFORMATION_SCHEMA.SCHEMATA';
    CachedDataSet.query(dbReference, {
      sql: sql,
      cache: false
    }, function(err, results) {
      logger.debug(prettyjson.render("Schemas: results"));
      return callback(err, _.map(results, function(schema) {
        return schema.schema;
      }));
    });
    return this;
  };

  CachedDataSet.queryDynamic = function(dbReference, callback) {
    var key, output, self;

    self = this;
    output = {};
    key = dbReference['key'];
    output = {};
    output[key] = {
      results: void 0,
      queryHash: void 0
    };
    CachedDataSet.buildSql(dbReference, function(err, queryHash) {
      var warning;

      if (err) {
        logger.error("Error building SQL: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        if (queryHash.d3Lookup.x !== void 0 && queryHash.d3Lookup.y !== void 0) {
          return dataSetCache.statementCacheGet(dbReference, queryHash, function(err, results) {
            if (err) {
              return callback(err);
            } else {
              output[key].queryHash = queryHash;
              if (results != null) {
                output[key].results = results;
                return callback(null, output);
              } else {
                return CachedDataSet.mysqlQuery(dbReference, queryHash, function(err, results) {
                  output[key].queryHash = queryHash;
                  output[key].results = results;
                  return callback(err, output);
                });
              }
            }
          });
        } else {
          if (queryHash.d3Lookup.x === void 0) {
            warning = "Could not generate data for " + key + ", no x set. Please make sure to group on some field.";
            output[key].warning = warning;
            logger.warn(warning);
          }
          if (queryHash.d3Lookup.y === void 0) {
            warning = "Could not generate data for " + key + ", no y set. Please make sure to aggregate a field.";
            output[key].warning = warning;
            logger.warn(warning);
          }
          output[key].queryHash = queryHash;
          return callback(err, output);
        }
      }
    });
    return self;
  };

  CachedDataSet.loadDataSet = function(doc, callback) {
    var self;

    self = this;
    doc = _.isString(doc) ? JSON.parse(doc) : doc;
    async.map(_.values(doc.dbReferences), self.queryDynamic, function(err, arrayOfDataSetResults) {
      if (err) {
        logger.error("Error querying dbReferences: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        _.each(arrayOfDataSetResults, function(dataSetResult, idx) {
          var stream;

          dataSetResult = _.values(dataSetResult)[0];
          stream = {
            key: dataSetResult.queryHash.d3Lookup.key,
            values: []
          };
          _.each(dataSetResult.results, function(item) {
            stream.values.push({
              x: item.x,
              xType: dataSetResult.queryHash.d3Lookup.xType,
              xGroupBy: dataSetResult.queryHash.d3Lookup.xGroupBy,
              y: item.y,
              yType: dataSetResult.queryHash.d3Lookup.yType
            });
            return dataSetResult.d3Data = stream;
          });
          return delete dataSetResult.results;
        });
        return callback(null, arrayOfDataSetResults);
      }
    });
    return self;
  };

  CachedDataSet.queryDataSet = function(arg, callback) {
    return this.loadDataSet(arg, function(err, results) {
      return callback(err, results);
    });
  };

  module.exports = CachedDataSet;

}).call(this);

/*
//@ sourceMappingURL=dbLogic.map
*/
