// Generated by CoffeeScript 1.6.2
(function() {
  var CachedDataSet, DbQuery, QueryBuilder, async, dataSetCache, logger, moment, mysql, prettyjson, settings, squel, utils, _;

  settings = require('../utilitis/settings');

  utils = require('../utilitis/utils');

  dataSetCache = require('./datasetCache');

  DbQuery = require('./dbQuery');

  QueryBuilder = require('./queryBuilder');

  squel = require('squel');

  _ = require('lodash');

  async = require('async');

  mysql = require('mysql');

  moment = require('moment');

  logger = require('tracer').colorConsole(utils.logger_config);

  prettyjson = require('prettyjson');

  CachedDataSet = {};

  CachedDataSet.queryDynamic = function(dbReference, callback) {
    var key, output, self;

    self = this;
    output = {};
    key = dbReference['key'];
    output = {};
    output[key] = {
      dbRefKey: dbReference.key,
      results: void 0,
      d3Data: void 0,
      queryHash: void 0
    };
    QueryBuilder.buildQuery(dbReference, function(err, queryHash) {
      var warning;

      if (err) {
        logger.error("Error building query: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        if (queryHash.d3Lookup.x !== void 0 && queryHash.d3Lookup.y !== void 0) {
          return dataSetCache.statementCacheGet(dbReference, queryHash, function(err, cachedD3Data) {
            if (err) {
              return callback(err);
            } else {
              output[key].queryHash = queryHash;
              if (cachedD3Data != null) {
                output[key].d3Data = cachedD3Data;
                return callback(null, output);
              } else {
                return DbQuery.query(dbReference, queryHash, function(err, dbResults) {
                  output[key].queryHash = queryHash;
                  output[key].results = dbResults;
                  return callback(err, output);
                });
              }
            }
          });
        } else {
          if (queryHash.d3Lookup.x === void 0) {
            warning = "Could not generate data for " + key + ", no x set. Please make sure to group on some field.";
            output[key].warning = warning;
            logger.warn(warning);
          }
          if (queryHash.d3Lookup.y === void 0) {
            warning = "Could not generate data for " + key + ", no y set. Please make sure to aggregate a field.";
            output[key].warning = warning;
            logger.warn(warning);
          }
          output[key].queryHash = queryHash;
          return callback(err, output);
        }
      }
    });
    return self;
  };

  CachedDataSet.loadDataSet = function(doc, callback) {
    var self;

    self = this;
    doc = _.isString(doc) ? JSON.parse(doc) : doc;
    async.map(_.values(doc.dbReferences), self.queryDynamic, function(err, arrayOfDataSetResults) {
      if (err) {
        logger.error("Error querying dbReferences: " + (prettyjson.render(err)));
        return callback(err);
      } else {
        _.each(arrayOfDataSetResults, function(dataSetResult, idx) {
          var refItem, stream, streams, uniqueMutliplexedXs, uniqueXs;

          logger.debug("arrayOfDataSetResults: " + (prettyjson.render(arrayOfDataSetResults)));
          dataSetResult = _.values(dataSetResult)[0];
          if (dataSetResult.d3Data == null) {
            if (dataSetResult.queryHash.d3Lookup.xMultiplex && dataSetResult.queryHash.d3Lookup.xMultiplex !== '') {
              logger.debug("Working with multiplexed data!");
              streams = [];
              uniqueMutliplexedXs = _.unique(_.map(dataSetResult.results, function(item) {
                return item[dataSetResult.queryHash.d3Lookup.xMultiplex];
              }));
              _.each(uniqueMutliplexedXs, function(uniqueX) {
                var stream;

                stream = {
                  key: "" + dataSetResult.queryHash.d3Lookup.key + " (" + uniqueX + ")",
                  values: []
                };
                stream.values = _(dataSetResult.results).filter(function(item) {
                  return item[dataSetResult.queryHash.d3Lookup.xMultiplex] === uniqueX;
                }).map(function(item) {
                  var _ref;

                  return {
                    x: item.x,
                    xOrig: item.x,
                    x: (_ref = dataSetResult.queryHash.d3Lookup.xType) === 'date' || _ref === 'datetime' ? +moment(item.x) : item.x,
                    xType: dataSetResult.queryHash.d3Lookup.xType,
                    xGroupBy: dataSetResult.queryHash.d3Lookup.xGroupBy,
                    xMultiplex: dataSetResult.queryHash.d3Lookup.xMultiplex,
                    xMultipleType: dataSetResult.queryHash.d3Lookup.xMultiplexType,
                    y: item.y || 0,
                    yType: dataSetResult.queryHash.d3Lookup.yType
                  };
                }).value();
                return streams.push(stream);
              });
              uniqueXs = _.without(_.unique(_.map(_.flatten(_.map(streams, function(stream) {
                return stream.values;
              }), true), function(item) {
                return item.x;
              })), void 0);
              uniqueXs.sort();
              refItem = _.first(_.first(streams).values);
              _.each(uniqueXs, function(uniqueX) {
                return _.each(streams, function(stream, streamIdx) {
                  var newItem, streamXs;

                  if (stream.key === "professional avg (APAC)" && uniqueX === '2010-09') {
                    streamXs = _.map(streams[streamIdx].values, function(v) {
                      return v.x;
                    });
                    streamXs.sort();
                  }
                  if (_.find(stream.values, function(v) {
                    return v.x === uniqueX;
                  }) === void 0) {
                    newItem = {
                      x: uniqueX,
                      y: 0,
                      xType: refItem.xType,
                      xGroupBy: refItem.xGroupBy,
                      xMultiplex: refItem.xMultiplex,
                      xMultipleType: refItem.xMultiplexType,
                      yType: refItem.yType
                    };
                    return streams[streamIdx].values.push(newItem);
                  }
                });
              });
              dataSetResult.d3Data = streams;
              delete dataSetResult.results;
              if ((dataSetResult.queryHash.cache != null) && (dataSetResult.d3Data != null) && dataSetResult.d3Data.length > 0) {
                dataSetCache.dataSetResultCachePut(doc, dataSetResult, function(err, outcome) {
                  if (err) {
                    return logger.error("Failed to cache the dataSetResult due to: " + (prettyjson.render(err)));
                  } else {
                    return callback(null, outcome);
                  }
                });
              }
            } else {
              if (dataSetResult.d3Data == null) {
                logger.debug("Working with non-multiplexed data!");
                stream = {
                  key: dataSetResult.queryHash.d3Lookup.key,
                  values: []
                };
                _.each(dataSetResult.results, function(item) {
                  var _ref;

                  stream.values.push({
                    xOrig: item.x,
                    x: (_ref = dataSetResult.queryHash.d3Lookup.xType) === 'date' || _ref === 'datetime' ? +moment(item.x) : item.x,
                    xType: dataSetResult.queryHash.d3Lookup.xType,
                    xGroupBy: dataSetResult.queryHash.d3Lookup.xGroupBy,
                    xMultiplex: dataSetResult.queryHash.d3Lookup.xMultiplex,
                    xMultipleType: dataSetResult.queryHash.d3Lookup.xMultiplexType,
                    y: item.y,
                    yType: dataSetResult.queryHash.d3Lookup.yType
                  });
                  return dataSetResult.d3Data = [stream];
                });
                delete dataSetResult.results;
              }
            }
            _.each(dataSetResult.d3Data, function(stream) {
              return stream.values.sort(function(a, b) {
                return a.x - b.x;
              });
            });
            if ((dataSetResult.queryHash.cache != null) && (dataSetResult.d3Data != null) && dataSetResult.d3Data.length > 0) {
              return dataSetCache.dataSetResultCachePut(dataSetResult, function(err, outcome) {
                if (err) {
                  return logger.error("Failed to cache the dataSetResult due to: " + (prettyjson.render(err)));
                } else {
                  logger.debug("Successfully cached d3Data.");
                  return callback(null, outcome);
                }
              });
            }
          }
        });
        return callback(null, arrayOfDataSetResults);
      }
    });
    return self;
  };

  CachedDataSet.queryDataSet = function(arg, callback) {
    return this.loadDataSet(arg, function(err, results) {
      return callback(err, results);
    });
  };

  module.exports = CachedDataSet;

}).call(this);

/*
//@ sourceMappingURL=dbLogic.map
*/
